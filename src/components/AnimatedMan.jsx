/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.15 public/models/Business Man.glb -o src/components/AnimatedMan.jsx -r public 
*/

import React, {
  useEffect,
  useRef,
  useMemo,
  useState,
  useCallback,
} from "react";
import {
  Image,
  useGLTF,
  useAnimations,
  Billboard,
  Text,
} from "@react-three/drei";
import { SkeletonUtils } from "three-stdlib";
import { useFrame, useGraph, useThree } from "@react-three/fiber";
import {
  socket,
  emojiAtom,
  animationAtom,
  charsTransformAtom,
  videoTextureRefsAtom,
} from "./SocketManager";
import { useAtom, useAtomValue } from "jotai";
import { useSpring, animated, easings } from "@react-spring/three";
import { easing } from "maath";
import { useLocalCharacter } from "../hooks/useStore";
import * as THREE from "three";
import { useGrid } from "../hooks/useGrid";
import { charsInfoItom } from "./SocketManager";
import { useXR } from "@react-three/xr";
import { useController } from "@react-three/xr";

const MOVE_SPEED = 2;
const FADE_TIME = 0.3;
const CAMERA_OFFSET = 6;
const ROTATION_SPEED = 3;
const CAMERA_LOOK_VERTICAL_OFFSET = 0.5;

export function AnimatedMan(props) {

  const { idChar } = props;
  const { type } = props;
  const { color, headColor } = props;
  const { vrPlayer } = props;
  const { isXR } = props;
  const { leftController, rightController } = props;
  // const leftController = isXR ? useController('left') : null
  // const rightController = isXR ? useController('right') : null
  //const { camera } = props.camera;
  const activeAnimation = useRef({
    forward: false,
    backward: false,
    left: false,
    right: false,
  });
  const actionSettingRef = useRef({});
  const currentActionRef = useRef(null);
  const group = useRef();

  const [charsTransform] = useAtom(charsTransformAtom);
  const [infos] = useAtom(charsInfoItom);
  const [animationsSynced] = useAtom(animationAtom);
  const [emojiData] = useAtom(emojiAtom);

  const { vector3ToGrid, gridToVector3, isWalkAble, isInside } = useGrid();

  const { scene, materials, animations } = type
    ? useGLTF("/models/girl.glb")
    : useGLTF("/models/girl1.glb");
  // console.log("animations", animations);
  const clone = useMemo(
    () => (scene ? SkeletonUtils.clone(scene) : null),
    [scene]
  );

  const { nodes } = useGraph(clone);
  const { actions, mixer } = useAnimations(animations, group); // mixer here not need update

  const [animation, setAnimation] = useState("Idle"); // TODO: remove this useState
  const [currentUrl, setCurrentUrl] = useState(); //  TODO: remove this useState

  const IDEA_POSITION = new THREE.Vector3(0, 2, -4).applyQuaternion(
    group.current ? group.current.quaternion : new THREE.Quaternion()
  );
  const IDEA_LOOKAT = new THREE.Vector3(0, 1, 30).applyQuaternion(
    group.current ? group.current.quaternion : new THREE.Quaternion()
  );
  const FIRST_CAMERA_MODE = true;
  const currentPosition = useRef(
    group.current
      ? new THREE.Vector3().copy(group.current.position).add(IDEA_POSITION)
      : IDEA_POSITION.clone()
  );
  const currentLookAt = useRef(new THREE.Vector3());

  const fontProps = {
    font: "/fonts/NotoSansJP-Bold.ttf",
    fontSize: 0.05,
    letterSpacing: -0.05,
    lineHeight: 1,
    "material-toneMapped": false,
  };

  const offsetGroup = [
    [0, 2, -4],
    [0, 2, -3],
    [0, 2, -2],
    [0, 2, -1],
    [0, 2, 0.1],
    [0, 2, 0.1],
  ];

  const robotSkinMaterial = materials.robot_M.clone();
  const robotHeadMaterial = materials.robot_color.clone();
  if (color) {
    robotSkinMaterial.color.set(color);
  }
  if (headColor) {
    robotHeadMaterial.color.set(headColor);
  }
  const [visible, setVisible] = useState(true);
  const [isThirdPerson, setIsThirdPerson] = useState(true);

  const chatActive = useRef(false);
  const camera = useThree((state) => state.camera);
  // const [_triggle, setTriggle] = useState(false);
  // console.log("camera",camera);
  const { gl: renderer } = useThree();
  const isProcessingInput = useRef(false);
  const applyRotation = useRef(0);
  //-------------------------------------------------------------------------------

  useEffect(() => {
    if (idChar != socket.id) return;
    if (isXR) {
      camera.near = 0.1;
      setIsThirdPerson(false);
    }
    else {
      group.current.position.set(6, 0, 3.5);

      setIsThirdPerson(true);
      socket.emit("transform", {
        position: [
          group.current.position.x,
          group.current.position.y,
          group.current.position.z,
        ],
        quaternion: [
          group.current.quaternion.x,
          group.current.quaternion.y,
          group.current.quaternion.z,
          group.current.quaternion.w,
        ],
      });

    }
  }, [isXR]);

  useEffect(() => {
    // set up animations
    // console.log("action", actions);
    const idleAction = actions["Idle"];
    const walkAction = actions["Walk"];
    const waveClip = actions["Wave"].getClip().clone();
    THREE.AnimationUtils.makeClipAdditive(waveClip);
    const waveAction = mixer.clipAction(waveClip);
    waveAction.repetitions = 1;

    actionSettingRef.current.Walk = { action: walkAction, addictive: false };
    actionSettingRef.current.Idle = { action: idleAction, addictive: false };
    actionSettingRef.current.Wave = { action: waveAction, addictive: true };
    setAnimation("Idle");
    playLocalAnimation("Idle");
    return () => {
      mixer.uncacheClip(waveClip);
      waveAction.fadeOut(0.1);
    };
  }, []);

  // useEffect(() => {
  //   if (idChar != socket.id) return;
  //   console.log("update camera")
  //   updateCamera(camera, 0.033);
  // }
  // , [_triggle]);

  useEffect(() => {
    if (idChar != socket.id) return;
    //play when local
    playLocalAnimation(animation);
  }, [animation]);

  useEffect(() => {
    if (idChar != socket.id) {
      // not local
      const anim = animationsSynced.find((c) => c.id === idChar);
      if (!anim) return;
      const baseActionData = actionSettingRef.current[anim?.base ?? "Idle"];
      if (
        baseActionData &&
        !baseActionData.addictive &&
        anim.base != currentActionRef.current
      ) {
        actionSettingRef.current[currentActionRef.current]?.action?.fadeOut(
          FADE_TIME
        );
        baseActionData.action?.reset().fadeIn(FADE_TIME).play();
        currentActionRef.current = anim.base; // cache current action's name
      }
      const addictiveActionData = actionSettingRef.current[anim.addictive];
      if (addictiveActionData && addictiveActionData.addictive) {
        addictiveActionData.action?.reset().fadeIn(FADE_TIME).play();
      }
    } else {
      const anim = animationsSynced.find((c) => c.id === socket.id);
      if (anim?.addictive)
        socket.emit("animation", { ...anim, addictive: null });
    }
  }, [animationsSynced]);

  useEffect(() => {
    if (emojiData && emojiData.id == idChar) {
      let i = emojiData.emojiId;
      setCurrentUrl(
        `./emoji/emoji-${i < 10 ? "0" : ""}${i}.png?${Math.random()}`
      );
    }
  }, [emojiData]);

  const handleKeyUp = useCallback((event) => {
    switch (event.keyCode) {
      case 38: //arrow up
      case 87: //w
        activeAnimation.current.forward = false;
        break;

      case 37: //arrow left
      case 65: //a
        activeAnimation.current.left = false;
        break;

      case 40: //arrow down
      case 83: //s
        activeAnimation.current.backward = false;
        break;

      case 39: //arrow right
      case 68: // d
        activeAnimation.current.right = false;
        break;
    }
  }, []);

  const handleKeyDown = useCallback((event) => {
    if (chatActive.current) return;
    switch (event.keyCode) {
      case 38: //arrow up
      case 87: //w
        activeAnimation.current.forward = true;
        break;

      case 37: //arrow left
      case 65: //a
        activeAnimation.current.left = true;
        break;

      case 40: //arrow down
      case 83: //s
        activeAnimation.current.backward = true;
        break;

      case 39: //arrow right
      case 68: // d
        activeAnimation.current.right = true;
        break;
    }
  }, []);

  useEffect(() => {
    if (charsTransform)
      for (const c of charsTransform) {
        if (c.id != idChar) continue;
        // console.log("useEffect", c);
        if (isXR && c.id == socket.id) {
          vrPlayer.position.set(...c.position);
        }
        else {
          group.current.position.set(...c.position);
          group.current.quaternion.set(...c.quaternion);
        }
      }

    if (idChar == socket.id) {
      // local player
      const gestureChangedUnsubcribe = useLocalCharacter.subscribe(
        (state) => state.gesture,
        onGestureChanged
      );

      const viewModeChangedUnsubcribe = useLocalCharacter.subscribe(
        (state) => state.viewMode,
        onViewModeChanged
      );

      const isChatActiveChangedUnsubcribe = useLocalCharacter.subscribe(
        (state) => state.isChatActive,
        onChatBoxChanged
      );

      window.addEventListener("keydown", handleKeyDown);
      window.addEventListener("keyup", handleKeyUp);

      return () => {
        window.removeEventListener("keydown", handleKeyDown);
        window.removeEventListener("keyup", handleKeyUp);
        gestureChangedUnsubcribe && gestureChangedUnsubcribe();
        viewModeChangedUnsubcribe && viewModeChangedUnsubcribe();
        isChatActiveChangedUnsubcribe && isChatActiveChangedUnsubcribe();
      };
    }
  }, []);

  useFrame((state, delta, frame) => {
    if (idChar === socket.id) {
      if (isXR && frame) {
        handleControllerMovement(state, delta)
      }
      else {
        if (!isThirdPerson && visible) {
          setVisible((pre) => false);
        }
        updateMove(delta, state.camera);
        updateCamera(state.camera, delta);
        const checking = state.camera.position.clone();
        // console.log("object", group.current.position, group.current.quaternion);
        //console.log("camera", state.camera.position, state.camera.quaternion);
        // console.log("in normal mode",group.current.position, state.camera.position);
      }
    } else {
      if (charsTransform)
        for (const c of charsTransform) {
          if (c.id === idChar) {
            easing.damp3(group.current.position, c.position, 0.2, delta);
            group.current.quaternion.slerp(
              new THREE.Quaternion(...c.quaternion),
              0.2
            );
            break;
          }
        }
    }
  });

  // ------------------------------------------------------------
  function handleControllerMovement(state, delta) {
    if (rightController && rightController.inputSource.gamepad && !isProcessingInput.current) {
      const rightGamePad = rightController.inputSource.gamepad;
      console.log("right input", rightGamePad.axes)
      const rightX = rightGamePad.axes[2];
      
      if (rightX && !isProcessingInput.current) {
        isProcessingInput.current = true;
        const direction = rightX > 0 ? 1 : -1;
        applyRotation.current += direction;
        const angle = -direction * Math.PI / 4;
        applyRotation.current = applyRotation.current % 8;
        const quaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
        vrPlayer.quaternion.multiply(quaternion);
      setTimeout(() => {
        // Processing is done, allow new inputs
        isProcessingInput.current = false;
      }, 200); // 200 milliseconds delay
    }

    }
    if (leftController && leftController.inputSource.gamepad) {
      const leftGamePad = leftController.inputSource.gamepad;
      const [inputX, inputY] = [leftGamePad.axes[2], leftGamePad.axes[3]];
      const joystickVector = new THREE.Vector3(inputX, 0, inputY);
      const angle = -applyRotation.current * Math.PI / 4;
      const quaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), angle);
      joystickVector.applyQuaternion(state.camera.quaternion.clone().multiply(quaternion));
      //joystickVector.applyQuaternion(vrPlayer.quaternion)
      joystickVector.y = 0;
      const newPosition = group.current.position.clone().add(joystickVector.multiplyScalar(delta));
      group.current.position.copy(checkValidWalkPosition(group.current.position, newPosition) ? newPosition : group.current.position);
    }

    vrPlayer.position.copy(group.current.position.clone());

    let direction = new THREE.Vector3();
    state.camera.getWorldDirection(direction);
    direction.y = 0;
    direction.normalize();

    let noYRotationQuaternion = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), direction);
    const yAxisInversion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI);
    noYRotationQuaternion.multiply(yAxisInversion);

    group.current.quaternion.copy(noYRotationQuaternion);

    socket.emit("transform", {
      position: [
        group.current.position.x,
        group.current.position.y,
        group.current.position.z,
      ],
      quaternion: [
        group.current.quaternion.x,
        group.current.quaternion.y,
        group.current.quaternion.z,
        group.current.quaternion.w,
      ]
    });
  }

  const playLocalAnimation = (name) => {
    const actionData = actionSettingRef.current[name];
    if (!actionData) return;
    if (!actionData.addictive) {
      socket.emit("animation", { base: name, addictive: null });
      actionSettingRef.current[currentActionRef.current]?.action?.fadeOut(
        FADE_TIME
      );
      actionData.action?.reset().fadeIn(FADE_TIME).play();
      currentActionRef.current = name; // cache current action's name
    } else {
      socket.emit("animation", {
        base: currentActionRef.current,
        addictive: name,
      });
      actionData.action?.reset().fadeIn(FADE_TIME).play();
    }
  };

  const onGestureChanged = (gesture) => {
    playLocalAnimation(gesture);
    console.log("onplay Gesture", gesture);
  };

  const onViewModeChanged = (viewMode) => {
    if (viewMode == true) {
      setIsThirdPerson(true);
    } else {
      setIsThirdPerson(false);
    }
  };

  const onChatBoxChanged = (isChatActive) => {
    chatActive.current = isChatActive;
  };

  function updateMove(delta, camera) {
    processMoveEvent(camera, delta);
    updateTransform(delta);
  }

  const checkValidWalkPosition = (cur, des) => {
    let isValidWalk = true;
    for (const c of charsTransform) {
      if (c.id == idChar) continue;
      const theirPos = new THREE.Vector3(
        c.position[0],
        c.position[1],
        c.position[2]
      );
      const curDistance = cur.distanceTo(theirPos);
      const desDistance = des.distanceTo(theirPos);
      if (desDistance < 0.5 && desDistance < curDistance) {
        isValidWalk = false;
        break;
      }
    }
    return isValidWalk && isWalkAble(des);
  };

  function processMoveEvent(camera, delta) {
    if (FIRST_CAMERA_MODE) {
      const controlObject = group.current;
      const _Q = new THREE.Quaternion();
      const _A = new THREE.Vector3();
      const _R = controlObject.quaternion.clone();

      const acceleration = new THREE.Vector3(1, 0.125, 100.0);
      const newVelocity = new THREE.Vector3();

      if (activeAnimation.current.forward) {
        newVelocity.z += acceleration.z * delta * MOVE_SPEED;
      }
      if (activeAnimation.current.backward) {
        newVelocity.z -= acceleration.z * delta * MOVE_SPEED;
      }
      if (activeAnimation.current.left) {
        _A.set(0, 1, 0);
        _Q.setFromAxisAngle(_A, 2.0 * Math.PI * delta * acceleration.y * ROTATION_SPEED);
        _R.multiply(_Q);
      }
      if (activeAnimation.current.right) {
        _A.set(0, 1, 0);
        _Q.setFromAxisAngle(_A, 2.0 * -Math.PI * delta * acceleration.y* ROTATION_SPEED);
        _R.multiply(_Q);
      }
      controlObject.quaternion.copy(_R);

      // const oldPosition = new THREE.Vector3();
      // oldPosition.copy(controlObject.position);

      const forward = new THREE.Vector3(0, 0, 1);
      forward.applyQuaternion(controlObject.quaternion);
      //console.log("forward", forward);
      forward.normalize();

      forward.multiplyScalar(newVelocity.z * delta);
      const destination = controlObject.position.clone().add(forward);

      if (checkValidWalkPosition(controlObject.position, destination)) {
        controlObject.position.copy(destination);
      } else {
        //try to move aslide map asix
        if (Math.abs(forward.x) > Math.abs(forward.z)) {
          forward.z = 0;
        } else {
          forward.x = 0;
        }
        destination.copy(controlObject.position.clone().add(forward));
        controlObject.position.copy(
          checkValidWalkPosition(controlObject.position, destination)
            ? destination
            : controlObject.position
        );
      }

      //updateCameraTarget(camera, delta);
      //setTriggle((pre) => !pre);
      return;
    }
  }

  function updateTransform(delta) {
    if (FIRST_CAMERA_MODE) {
      if (
        activeAnimation.current.forward ||
        activeAnimation.current.backward ||
        activeAnimation.current.left ||
        activeAnimation.current.right
      ) {
        socket.emit("transform", {
          position: [
            group.current.position.x,
            group.current.position.y,
            group.current.position.z,
          ],
          quaternion: [
            group.current.quaternion.x,
            group.current.quaternion.y,
            group.current.quaternion.z,
            group.current.quaternion.w,
          ],
          rotation: [
            group.current.rotation.x,
            group.current.rotation.y,
            group.current.rotation.z,
          ],
        });
        setAnimation("Walk");
      } else {
        setAnimation("Idle");
      }

      return;
    }
  }

  const calculateIdealOffset = () => {
    const idealOffset = new THREE.Vector3();
    for (let i = 0; i < offsetGroup.length; i++) {
      idealOffset.set(...offsetGroup[i]);
      idealOffset.applyQuaternion(group.current.quaternion);
      idealOffset.add(group.current.position);
      if (isInside(idealOffset)) {
        return idealOffset;
      }
    }
    return idealOffset;
  };

  const calculateIdealLookat = (lookAtPos) => {
    // const idealLookat = lookAtPos;
    // idealLookat.applyQuaternion(group.current.quaternion);
    // idealLookat.add(group.current.position);
    // console.log("lookAtPos", group.current.quaternion, idealLookat.quaternion, idealLookat.position);
    // return idealLookat;
    currentLookAt.current.set(...lookAtPos);
    currentLookAt.current.applyQuaternion(group.current.quaternion);
    currentLookAt.current.add(group.current.position);
    //console.log("lookAtPos", group.current.quaternion,  currentLookAt.current);
  };

  const updateCameraTarget = (camera, delta) => {
    if (camera == null) return;
    camera.fov = 30;
    camera.near = 1.5;
    const idealOffset = calculateIdealOffset();

    const t = 1.0 - Math.pow(0.01, delta * ROTATION_SPEED);

    currentPosition.current.lerp(idealOffset, t);
    camera.position.copy(currentPosition.current);
  };

  const updateCameraTargetFPV = (camera, delta) => {
    if (camera == null) return;
    camera.fov = 60;
    camera.near = 0.1;
    const idealOffset = new THREE.Vector3().set(0, 1.5, 0);
    idealOffset.applyQuaternion(group.current.quaternion);
    idealOffset.add(group.current.position);

    camera.position.copy(idealOffset);
  };

  const updateCamera = (camera, delta) => {
    if (isThirdPerson) {
      //console.log("pre quaternion", camera.quaternion);
      updateCameraTarget(camera, delta);
      //console.log("pre quaternion 1", camera.quaternion);
      //const idealLookat = calculateIdealLookat(new THREE.Vector3(0, 1, 30));
      calculateIdealLookat([0, 1, 30]);
      camera.lookAt(currentLookAt.current); //this make diff in quaternion, but why ??
      //console.log("pre quaternion 2", camera.quaternion);
      camera.updateProjectionMatrix();
      //console.log("pre quaternion 3", camera.quaternion);
    } else {
      updateCameraTargetFPV(camera, delta);
      // const idealLookat = calculateIdealLookat(new THREE.Vector3(0, 4, 30));
      // camera.lookAt(idealLookat);
      calculateIdealLookat([0, 4, 30]);
      camera.lookAt(currentLookAt.current);
      camera.updateProjectionMatrix();
    }
  };

  const [videoTextureRefs] = useAtom(videoTextureRefsAtom);

  useEffect(() => {
    console.log(videoTextureRefs);
    console.log("count: " + videoTextureRefs.length);
    videoTextureRefs.forEach((e) => {
      console.log("userID: " + idChar + " webcamId: " + e);
    });
  }, [videoTextureRefs]);
  return (
    <group ref={group} {...props} dispose={null} name={`character-${idChar}`}>
      <Billboard
        position={[0, 2, 0]}
        follow={true}
        lockX={false}
        lockY={false}
        lockZ={false} // Lock the rotation on the z axis (default=false)
      >
        <Text
          outlineColor={"#1e4a6b"}
          outlineWidth={0.001}
          position={[0, 0, 0.025]}
          clipRect={[-0.25, -0.1, 0.25, 0.1]}
          color="white"
          strokeColor="white"
          textAlign="center"
          {...fontProps}
        >
          {infos.find((i) => i.id === idChar)?.name ?? ""}
        </Text>
      </Billboard>

      <group name="Scene">
        <EmojiPlayer currentUrl={currentUrl} />
        <group
          name="Armature"
          position={[0, 0.85, 0]}
          scale={0.3}
          visible={isThirdPerson}
        >
          <primitive object={nodes.body} />
          <TexturedPlane
            name="robot_screen"
            geometry={nodes.robot_screen.geometry}
            material={materials.Black}
            skeleton={nodes.robot_screen.skeleton}
            userId={idChar.toString()}
            eyeName="eyes"
            eyeMaterial={materials.robot_eye}
            eyeGeometry={nodes.eyes.geometry}
            eyeSkeleton={nodes.eyes.skeleton}
          />

          <skinnedMesh
            name="robot_color"
            geometry={nodes.robot_color.geometry}
            material={robotHeadMaterial}
            skeleton={nodes.robot_color.skeleton}
          />
          <skinnedMesh
            name="robot"
            geometry={nodes.robot.geometry}
            material={robotSkinMaterial}
            skeleton={nodes.robot.skeleton}
          />

          <skinnedMesh
            name="robot001"
            geometry={nodes.robot001.geometry}
            skeleton={nodes.robot001.skeleton}
          >
            <meshStandardMaterial
              transparent={true}
              opacity={0.05}
              metalness={0.9}
              roughness={0}
              color={"black"}
            ></meshStandardMaterial>
          </skinnedMesh>
        </group>
      </group>
    </group>
  );
}

useGLTF.preload("/models/girl.glb");

const TexturedPlane = ({
  name,
  geometry,
  skeleton,
  material,
  userId,
  eyeName,
  eyeMaterial,
  eyeGeometry,
  eyeSkeleton,
}) => {
  const [videoTextureRefs] = useAtom(videoTextureRefsAtom);
  const [videoTexture, setVideoTexture] = useState(null);
  const [mat, setMat] = useState(null);
  useEffect(() => {
    const find = String(userId.toString() + "_video");
    let videoElement = document.getElementById(find);
    if (videoElement) {
      let newTex = new THREE.VideoTexture(videoElement);
      newTex.colorSpace = "srgb";
      setVideoTexture(newTex);
    } else {
      setVideoTexture((a) => (a = null));
    }
  }, [videoTextureRefs]);
  useEffect(() => {
    if (videoTexture) {
      const videoMaterial = new THREE.MeshBasicMaterial({
        map: videoTexture,
        reflectivity: 0,
        lightMap: null,
        fog: false,
        envMap: null,
      });
      setMat(videoMaterial);
    } else {
      setMat(material);
    }
  }, [videoTexture]);
  return (
    <group>
      <skinnedMesh
        name={name}
        geometry={geometry}
        material={mat}
        skeleton={skeleton}
      />
      {!videoTexture && (
        <skinnedMesh
          name={eyeName}
          geometry={eyeGeometry}
          material={eyeMaterial}
          skeleton={eyeSkeleton}
        ></skinnedMesh>
      )}
    </group>
  );
};

function EmojiPlayer({ currentUrl }) {
  const refEmojiGroup = useRef();

  useEffect(() => {
    if (!currentUrl) return;
    // console.log("currentUrl", currentUrl);
    refEmojiGroup.current.visible = true;
    api.set({
      position: [0, -0.5, 0],
      scale: 0,
    });
    api.start({
      to: {
        position: [0, 0, 0],
        scale: 1,
      },
      reset: true,
      onStart: () => (refEmojiGroup.current.visible = true),
      onResolve: () => {
        (refEmojiGroup.current.visible = false),
          api.set({
            position: [0, -0.5, 0],
            scale: 0,
          });
      },
    });
  }, [currentUrl]);

  const [spring, api] = useSpring(
    {
      from: {
        position: [0, -0.5, 0],
        scale: 0,
      },
      config: {
        duration: 2000,
        easing: easings.easeOutElastic,
      },
      loop: false,
    },
    []
  );

  useFrame((state, delta) => {
    refEmojiGroup.current.lookAt(state.camera.position); // SE
  });

  return (
    <group ref={refEmojiGroup} position={[0, 2.2, 0.2]}>
      <animated.group {...spring}>
        {currentUrl && (
          <Image
            url={currentUrl}
            position={[0, 0, 0]}
            scale={0.4}
            transparent={true}
          />
        )}
      </animated.group>
    </group>
  );
}
